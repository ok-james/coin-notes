(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{466:function(t,a,r){"use strict";r.r(a);var s=r(65),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("p",[t._v("主要用到哈希（Cryptographic hash function）和签名")]),t._v(" "),r("h2",{attrs:{id:"哈希"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#哈希"}},[t._v("#")]),t._v(" 哈希")]),t._v(" "),r("h3",{attrs:{id:"特性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#特性"}},[t._v("#")]),t._v(" 特性")]),t._v(" "),r("ol",[r("li",[r("p",[t._v("哈希碰撞")]),t._v(" "),r("p",[t._v("x ≠ y ，但是 Hash(x) = Hash(y)")]),t._v(" "),r("p",[t._v("抗碰撞（collision resistance），不是不会发生碰撞，而是难以发生碰撞。")])]),t._v(" "),r("li",[r("p",[t._v("单向的（hiding），不可逆的，也就是无法从输出的哈希值反推出输入，hiding 这个特性的前提是输入的取值范围要足够大，也要足够均匀，比如假设，只有三个输入，那么即使使用 hiding 的特性，但是只要知道这三个输入，以及哈希函数，就可以算出输出，然后一对比就可以知道结果了。\n如果原始输入的取值范围不够大的话，可以在原始输入的后面拼接一个随机数，从而加大取值范围。")])]),t._v(" "),r("li",[r("p",[t._v("难题友好（puzzle friendly），挖矿的过程，没有捷径，只能通过大量的工作（工作量证明 proof of work），计算很难，验证很容易（difficult to solve, but easy to verify）。")])])]),t._v(" "),r("h3",{attrs:{id:"比特币使用的哈希函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#比特币使用的哈希函数"}},[t._v("#")]),t._v(" 比特币使用的哈希函数")]),t._v(" "),r("p",[t._v("SHA-256")]),t._v(" "),r("p",[t._v("Secure Hash Algorithm")]),t._v(" "),r("h2",{attrs:{id:"签名"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#签名"}},[t._v("#")]),t._v(" 签名")]),t._v(" "),r("p",[t._v("在比特币中，一个公私钥对，就代表一个账户。")]),t._v(" "),r("p",[t._v("公钥 / 私钥对，非对称加密算法（asymmetric encryption algorithm）。")]),t._v(" "),r("p",[t._v("加密用的是接收人的公钥，然后将消息发送给接收人，接收人再用私钥进行解密。")]),t._v(" "),r("p",[t._v("签名用的是私钥，验证签名用的是同一个公私钥对中的公钥。")]),t._v(" "),r("p",[t._v("生成公私钥的过程需要有一个好的随机源（a good source of randomness）。")])])}),[],!1,null,null,null);a.default=e.exports}}]);