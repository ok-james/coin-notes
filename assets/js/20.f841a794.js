(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{472:function(v,_,a){"use strict";a.r(_);var t=a(65),r=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h2",{attrs:{id:"全节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全节点"}},[v._v("#")]),v._v(" 全节点")]),v._v(" "),a("ul",[a("li",[v._v("一直在线")]),v._v(" "),a("li",[v._v("在本地硬盘上维护完整的区块链信息")]),v._v(" "),a("li",[v._v("在内存里维护 UTXO 集合，以便快速检验交易的正确性")]),v._v(" "),a("li",[v._v("监听比特币网络上的交易信息，验证每个交易的合法性")]),v._v(" "),a("li",[v._v("决定哪些交易会被打包到区块里")]),v._v(" "),a("li",[v._v("监听别的矿工挖出来的区块，验证其合法性\n"),a("ul",[a("li",[v._v("验证区块中每个交易都要是合法的，包括铸币的交易")]),v._v(" "),a("li",[v._v("发布的区块是否符合难度要求，也就是计算 block header 的哈希是否符合目标阈值，同时也要确定阈值是否设置的正确")]),v._v(" "),a("li",[v._v("检验是否是最长合法连")])])]),v._v(" "),a("li",[v._v("挖矿\n"),a("ul",[a("li",[v._v("决定沿着哪条链挖下去？")]),v._v(" "),a("li",[v._v("当出现等长的分叉的时候，选择哪一个分叉？")])])])]),v._v(" "),a("h2",{attrs:{id:"轻节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#轻节点"}},[v._v("#")]),v._v(" 轻节点")]),v._v(" "),a("ul",[a("li",[v._v("不是一直在线")]),v._v(" "),a("li",[v._v("不用保存整个区块链，只要保存每个区块的块头")]),v._v(" "),a("li",[v._v("不用保存全部交易，只保存与自己相关的交易")]),v._v(" "),a("li",[v._v("无法检验大多数交易的合法性，只能检验与自己相关的那些交易的合法性")]),v._v(" "),a("li",[v._v("无法检测网上发布的区块的正确性")]),v._v(" "),a("li",[v._v("可以验证挖矿的难度")]),v._v(" "),a("li",[v._v("只能检测哪个是最长链，不知道哪个是最长合法链")])]),v._v(" "),a("h2",{attrs:{id:"安全性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#安全性"}},[v._v("#")]),v._v(" 安全性")]),v._v(" "),a("p",[v._v("比特币的安全性是通过密码学以及共识机制两者结合在一起来保证的")]),v._v(" "),a("p",[v._v("密码学上的公私钥机制保证只有拥有私钥的人才能对交易进行签名")]),v._v(" "),a("p",[v._v("而共识机制保证，不拥有私钥签名的非法交易不会被打包到区块中，否则密码学就无用武之地了")]),v._v(" "),a("h2",{attrs:{id:"挖矿"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#挖矿"}},[v._v("#")]),v._v(" 挖矿")]),v._v(" "),a("p",[v._v("一开始使用 CPU 挖矿，后来又使用 GPU 挖矿。现在都用 ASIC（Application Specific Integrated  Circuit）芯片挖矿， ASIC 一般只能用于一种虚拟币的挖矿。趋势是从通用变得越来越专用。")]),v._v(" "),a("h2",{attrs:{id:"矿池"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#矿池"}},[v._v("#")]),v._v(" 矿池")]),v._v(" "),a("p",[v._v("一般地，矿池的架构是一个全节点来驱动很多矿机，相应地，就是有一个矿主（pool manager），其对应多个矿工（miner），矿工只负责计算 hash 值，全节点所有其他的功能都由矿主来负责。")]),v._v(" "),a("p",[v._v("一般情况下，矿主与矿工之间是通过一个分布式的通信协议来相互通信的，矿主负责把任务分配给矿工，矿工计算成功之后，会把结果返回给矿主，然后在整个矿池中，根据不同矿工的工作量来分配收益。")]),v._v(" "),a("p",[v._v("那现在问题就变成了如何确定不同矿工的工作量呢？")]),v._v(" "),a("p",[v._v("答案就是降低挖矿难度，假设当前真正的挖矿难度是 100 ，那么就为矿工设置一个 50 的挖矿难度，一旦矿工得到一个符合 50 难度的 nonce 值，称为 Share ，就把这个区块交给矿主，这个 Share 对于挖矿来说，是没有价值的，其唯一的价值就是作为矿工的工作量证明，也就是证明它的算力，当某个矿工真正挖到满足难度 100 的 nonce 时，会根据 Share 分配收益。")]),v._v(" "),a("h3",{attrs:{id:"危害"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#危害"}},[v._v("#")]),v._v(" 危害")]),v._v(" "),a("p",[v._v("使 51% 攻击变得更加容易，因为可以更容易地吸引到不明真相的矿工为其提供算力。")]),v._v(" "),a("h4",{attrs:{id:"通过-51-算力可以完成的攻击"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通过-51-算力可以完成的攻击"}},[v._v("#")]),v._v(" 通过 51% 算力可以完成的攻击")]),v._v(" "),a("ol",[a("li",[v._v("分叉攻击")]),v._v(" "),a("li",[v._v("Boycott ，可以封锁一个账户的交易，比如，假设 X 矿池具有 51% 的算力，希望封锁 A 这个账户。假设， Y 这个矿工（或矿池）将与 A 账户相关的交易发布到区块链上，那么， X 就可以马上发起分叉攻击，产生一个不包含 A 账户相关交易的区块，这样其他矿工/矿池预期到这种结果后，就不会再打包 A 账户相关的交易，因为打包了，其对应的区块就会被分叉攻击。")])]),v._v(" "),a("h3",{attrs:{id:"问题与解答"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题与解答"}},[v._v("#")]),v._v(" 问题与解答")]),v._v(" "),a("h4",{attrs:{id:"有没有可能-一个矿工挖到一个区块后-不提交给矿主"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#有没有可能-一个矿工挖到一个区块后-不提交给矿主"}},[v._v("#")]),v._v(" 有没有可能，一个矿工挖到一个区块后，不提交给矿主？")]),v._v(" "),a("p",[v._v("这是不可能的，因为矿主分配的任务中，铸币交易的收款地址填的是矿主的地址。")]),v._v(" "),a("h4",{attrs:{id:"如果矿工一开始就将铸币交易的收款地址修改为自己的地址-这个会有问题吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如果矿工一开始就将铸币交易的收款地址修改为自己的地址-这个会有问题吗"}},[v._v("#")]),v._v(" 如果矿工一开始就将铸币交易的收款地址修改为自己的地址，这个会有问题吗？")]),v._v(" "),a("p",[v._v("这个也没有问题，因为这样的话，当该矿工在提交 Share 时，矿主会发现地址的变动，从而不承认这个 Share 的工作量。此时，这个矿工就退回了单干的模式。")])])}),[],!1,null,null,null);_.default=r.exports}}]);