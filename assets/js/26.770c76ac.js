(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{479:function(t,v,_){"use strict";_.r(v);var a=_(65),e=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"btc-账户体系存在的问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#btc-账户体系存在的问题"}},[t._v("#")]),t._v(" BTC 账户体系存在的问题")]),t._v(" "),_("ol",[_("li",[t._v("UTXO 与日常的支付体系相比，使用体验有很大不同。在日常生活中，我们的银行账户收到一笔钱以后，在支付的时候，不需要关心花出去的钱的来源。而对于 UTXO 来说，必须知道之前交易的输出（Output）才可以；")]),t._v(" "),_("li",[t._v("对于 UTXO 来说，即使转账的金额小于一个交易的输出，也需要以该输出作为输入，并将剩余的 BTC 以新的 UTXO 的形式存入原账户或者新创建的账户。")])]),t._v(" "),_("h2",{attrs:{id:"eth-的账户体系"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#eth-的账户体系"}},[t._v("#")]),t._v(" ETH 的账户体系")]),t._v(" "),_("p",[t._v("ETH 的账户系统与银行的账户体系是类似的，是基于账户的模型，系统需要显式地记录每个账户上有多少个 ETH ，而在支付的时候，也不需要指定币的来源。")]),t._v(" "),_("h3",{attrs:{id:"双花-double-spending-攻击"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#双花-double-spending-攻击"}},[t._v("#")]),t._v(" 双花（double spending）攻击")]),t._v(" "),_("p",[t._v("这样的账户系统可以天然的防止 "),_("strong",[t._v("双花")]),t._v(" 攻击，因为一个人花了一次钱以后，他如果选择再花一次，那就再从账户余额中扣除即可，如果余额不足，则交易会直接失败。 "),_("strong",[t._v("双花")]),t._v(" 攻击是花钱的人不诚实，希望多次支付。")]),t._v(" "),_("h4",{attrs:{id:"比特币是如何防止双花攻击的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#比特币是如何防止双花攻击的"}},[t._v("#")]),t._v(" 比特币是如何防止双花攻击的？")]),t._v(" "),_("p",[t._v("比特币防止双花攻击的方式与防止重放攻击的方式是相同的，详情可查看下面《比特币是如何防止重放攻击的？》。这里多说一句，比特币防止双花攻击时，不需要检验账户的余额。")]),t._v(" "),_("p",[t._v("基于余额的检查与基于 output 的检查有什么区别呢？")]),t._v(" "),_("p",[t._v("举个例子，假设一个用户 A 的一个账户下有 7 个 BTC，只不过存在于两个 output 中，分别是 3 个和 4 个。现在用户先将 5 个 BTC 转给 B ，然后 "),_("em",[t._v("马上")]),t._v(" 又转 1 个 BTC 给 C 。")]),t._v(" "),_("p",[t._v("如果是基于余额的检查，那么两个交易应该都能成功，因为用户 A 的余额是足以支付这两笔交易的。")]),t._v(" "),_("p",[t._v("但是，如果是基于 output 的检查，这两个交易只能有一个成功。因为第一笔交易需要使用到两个 output ，而每个 output 只能花一次，所以，再 "),_("em",[t._v("马上")]),t._v(" 发起第二个请求时，花费的肯定是这两个 output 中的一个，但是这两个 output 已经花过了，所以第二个交易是一个双花，不会成功。")]),t._v(" "),_("p",[t._v("当然，具体哪个交易会成功，是不一定的。但是，只会有一个成功。")]),t._v(" "),_("h4",{attrs:{id:"以太坊是如何防止双花攻击的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#以太坊是如何防止双花攻击的"}},[t._v("#")]),t._v(" 以太坊是如何防止双花攻击的？")]),t._v(" "),_("p",[t._v("正如上面提到的，对于 ETH 来说，是直接查询账户的余额，余额足够支付，则交易成功，否则，交易失败。")]),t._v(" "),_("h3",{attrs:{id:"重放-replay-attack-攻击"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#重放-replay-attack-攻击"}},[t._v("#")]),t._v(" 重放（replay attack）攻击")]),t._v(" "),_("p",[t._v("这样的账户体系虽然可以防止 "),_("strong",[t._v("双花")]),t._v(" 攻击，但却更容易遭受 "),_("strong",[t._v("重放")]),t._v(" 攻击。 "),_("strong",[t._v("重放")]),t._v(" 攻击是指，A 向 B 发起一个支付交易并成功后， B 将该交易在区块链上重复发布，从而形成多次的转账交易。 "),_("strong",[t._v("重放")]),t._v(" 攻击是收钱的人不诚实，希望多次收款。")]),t._v(" "),_("h4",{attrs:{id:"比特币是如何防止重放攻击的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#比特币是如何防止重放攻击的"}},[t._v("#")]),t._v(" 比特币是如何防止重放攻击的？")]),t._v(" "),_("p",[t._v("我觉得视频中，老师对于比特币防止 "),_("strong",[t._v("重放")]),t._v(" 攻击的解释不太准确。我的理解是，比特币可以防止重放攻击是因为一个 output 只能被花费一次，也就是说，要花费一个 output ，就必须全部花费出去，如果有剩余，则以找零的形式存储在另一个 output 中。")]),t._v(" "),_("p",[t._v("在一个交易的 inputs 中会指定其所对应的前一个交易的 output ，然后会在当前交易中生成一个或多个新的 output ，如果对这个交易进行重放，由于前一次交易的 output 已经被花费过一次，所以重放无效。")]),t._v(" "),_("h4",{attrs:{id:"以太坊中如何防止重放攻击"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#以太坊中如何防止重放攻击"}},[t._v("#")]),t._v(" 以太坊中如何防止重放攻击？")]),t._v(" "),_("p",[t._v("在交易中加一个交易次数的字段 "),_("code",[t._v("nonce")]),t._v(" ，这个交易次数是当前账户一共发起的交易次数的计数。")]),t._v(" "),_("p",[t._v("注意将这个 "),_("code",[t._v("nonce")]),t._v(" 与区块链的 block header 中的 "),_("code",[t._v("nonce")]),t._v(" 区分开来，这个 "),_("code",[t._v("nonce")]),t._v(" 是每个交易都会存在的字段。")]),t._v(" "),_("h3",{attrs:{id:"账户类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#账户类型"}},[t._v("#")]),t._v(" 账户类型")]),t._v(" "),_("h4",{attrs:{id:"外部账户-externally-owned-account"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#外部账户-externally-owned-account"}},[t._v("#")]),t._v(" 外部账户 externally owned account")]),t._v(" "),_("p",[_("code",[t._v("外部账户")]),t._v(" 是由人控制的，通过公私钥对创建的账户。")]),t._v(" "),_("p",[_("code",[t._v("外部账户")]),t._v(" 具有的字段：")]),t._v(" "),_("ul",[_("li",[t._v("余额 balance")]),t._v(" "),_("li",[t._v("交易次数 nonce")])]),t._v(" "),_("h4",{attrs:{id:"合约账户-smart-contract-account"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#合约账户-smart-contract-account"}},[t._v("#")]),t._v(" 合约账户 smart contract account")]),t._v(" "),_("p",[_("code",[t._v("合约账户")]),t._v(" 不是通过公私钥对创建的， "),_("code",[t._v("合约账户")]),t._v(" 是通过 "),_("code",[t._v("外部账户")]),t._v(" 创建智能合约时生成的。 "),_("code",[t._v("合约账户")]),t._v(" 不能主动发起一个交易，必须通过 "),_("code",[t._v("外部账户")]),t._v(" 进行调用。")]),t._v(" "),_("p",[_("code",[t._v("合约账户")]),t._v(" 除了拥有上面提到的 "),_("code",[t._v("外部账户")]),t._v(" 所拥有的字段之外，还具有额外的如下字段：")]),t._v(" "),_("ul",[_("li",[t._v("代码 code")]),t._v(" "),_("li",[t._v("存储 storage")])]),t._v(" "),_("p",[t._v("创建智能合约时，会返回一个地址，通过这个地址就可以调用智能合约。")]),t._v(" "),_("h4",{attrs:{id:"eth-设计新的账户体系的原因"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#eth-设计新的账户体系的原因"}},[t._v("#")]),t._v(" ETH 设计新的账户体系的原因")]),t._v(" "),_("p",[t._v("以太坊账户体系的好处是，账户比较稳定，不像 BTC 那样，生成一个 UTXO 以后，就会生成新的地址。智能合约需要稳定的账户体系，否则智能合约的执行可能就会有问题了。")]),t._v(" "),_("p",[t._v("个人理解：我不太同意老师的观点，BTC 在生成 UTXO 时，找零输出的地址不一定需要新生成，这样做，主要是为了安全性考虑，因为在发生交易时，会暴露公钥，为了防止通过公钥反推出私钥，才重新生成一个新的公私钥以及地址。")]),t._v(" "),_("p",[t._v("而对于以太坊来说，如果因为用户的账户有问题而导致智能合约的执行有问题的话，那也需要智能合约考虑到这种异常情况，并由用户承担相应的后果。")]),t._v(" "),_("p",[t._v("所以，我不太认同老师的观点。")])])}),[],!1,null,null,null);v.default=e.exports}}]);