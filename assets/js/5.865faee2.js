(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{440:function(t,v,_){t.exports=_.p+"assets/img/trie.8e031578.png"},441:function(t,v,_){t.exports=_.p+"assets/img/patricia_tree.f29e83e0.png"},442:function(t,v,_){t.exports=_.p+"assets/img/modified_MPT.e0512e9b.png"},443:function(t,v,_){t.exports=_.p+"assets/img/saved_MPT.def4bdb0.png"},480:function(t,v,_){"use strict";_.r(v);var e=_(65),a=Object(e.a)({},(function(){var t=this,v=t.$createElement,e=t._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("这一节主要讲解 ETH 是通过怎样的数据结构来存储账户信息的，包括余额、交易次数等。本质上需要存储的是从账户地址到账户状态的映射（ addr —> state）。")]),t._v(" "),e("p",[t._v("在 ETH 中，账户地址是 160 bits 的，一般表示成一个 40 位的 16 进制的数。")]),t._v(" "),e("p",[t._v("在比特币中，每个区块都对应着一个梅克尔树形式的交易树，并且会在块头中存储该梅克尔树的根哈希值。")]),t._v(" "),e("p",[t._v("而在以太坊中，每个区块都对应着三棵树，分别是 "),e("code",[t._v("状态树")]),t._v(" 、 "),e("code",[t._v("交易树")]),t._v(" 和 "),e("code",[t._v("收据树")]),t._v(" ，在块头中，有三个字段分别存储着这三棵树的根哈希值。")]),t._v(" "),e("p",[t._v("而这一小节，主要讲解 "),e("code",[t._v("状态树")]),t._v(" ，用来存储地址到状态的映射的树。")]),t._v(" "),e("h2",{attrs:{id:"数据结构的讨论"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据结构的讨论"}},[t._v("#")]),t._v(" 数据结构的讨论")]),t._v(" "),e("p",[t._v("存储 "),e("code",[t._v("状态树")]),t._v(" 的数据结构需要满足如下要求：")]),t._v(" "),e("ol",[e("li",[t._v("增、改、查的效率要高")]),t._v(" "),e("li",[t._v("能够方便的计算所有账户的根哈希值")]),t._v(" "),e("li",[t._v("节省存储空间，可以在连续的区块之间共享未修改的账户状态，也就是说，这个数据结构必须稳定，稳定的意思是，即使账户的状态修改，对于整个数据结构的结构来说，也没有影响。")]),t._v(" "),e("li",[t._v("能够保证 "),e("code",[t._v("状态树")]),t._v(" 的结构在整个网络的所有节点中都保持一致，即使节点之间没有互相同步过这个结构。")])]),t._v(" "),e("p",[t._v("有如下几个选择：")]),t._v(" "),e("h3",{attrs:{id:"哈希表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#哈希表"}},[t._v("#")]),t._v(" 哈希表")]),t._v(" "),e("p",[t._v("主要的问题是一旦一个区块内的所有交易和合约都执行完以后，需要根据最新的哈希表重新计算根哈希值。")]),t._v(" "),e("p",[t._v("个人疑问：是不是如果能够记录具体是哪个账户发生了变化，也不需要重新计算整个 "),e("code",[t._v("状态树")]),t._v(" ？")]),t._v(" "),e("p",[t._v("个人理解：与接下来讨论的 "),e("code",[t._v("Modified MPT")]),t._v(" 的方式进行比较后，我觉得，这种方式真正不好的地方是，无法在两个连续的区块之间重用未修改的账户状态，因为一旦账户的状态修改后，就可能跑到哈希表的另一个位置上，也就是说，前后两个区块的哈希表的结构可能会差别很大，这样就需要每个区块都保存一个所有账户的副本。")]),t._v(" "),e("p",[t._v("而对于 "),e("code",[t._v("Modified MPT")]),t._v(" 结构来说，连续两个区块的结构都不会有大的改变，只有新增账户时，结构才会发生变化，而且，这不影响已有账户的结构。注意，我说的是结构。这样，就可以很方便的重用之前未修改的账户状态，而只需要在当前区块中记录已修改的账户即可。")]),t._v(" "),e("h3",{attrs:{id:"梅克尔树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#梅克尔树"}},[t._v("#")]),t._v(" 梅克尔树")]),t._v(" "),e("p",[t._v("如果直接使用梅克尔树的结构存储账户，实际上就是用数组结构来存储账户。")]),t._v(" "),e("h4",{attrs:{id:"如果是未排序的数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如果是未排序的数组"}},[t._v("#")]),t._v(" 如果是未排序的数组")]),t._v(" "),e("p",[t._v("如果是未排序的数组，那么查的效率就会很慢。")]),t._v(" "),e("p",[t._v("老师在视频中还提出一个这种方式的问题，就是，在不同的节点之间，账户在数组中的顺序可能是不同的，从而无法在所有节点中保持唯一的一个状态树。")]),t._v(" "),e("p",[t._v("我不太认同老师的说法，理由如下：一旦确定一个新区块以后，该区块需要传播给所有其他节点，其他节点收到该区块后，需要执行该区块内的交易以及合约调用。该区块内所有交易以及合约调用的顺序都是相同的，那么，节点在执行这些交易与合约时，顺序应该也是相同的，假设遇到一个新账户，那么只需要直接放到数组的末尾就可以，理论上来说，在所有节点之间，该数组的状态是相同的。")]),t._v(" "),e("p",[t._v("所以，我认为，最严重的问题还是查的效率太慢了，同时造成改的效率也慢。")]),t._v(" "),e("h4",{attrs:{id:"如果是已排序的数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如果是已排序的数组"}},[t._v("#")]),t._v(" 如果是已排序的数组")]),t._v(" "),e("p",[t._v("如果是已排序的数组，查找的效率确实能快一点，但是新增的效率就会慢得多，总得来说，增、改、查的效率都比较慢，因为理论上来说，账户的总数量是 2^160 ，在这样的数量级下，这样的效率很明显是无法接受的。")]),t._v(" "),e("p",[t._v("而且，一旦新增数据，该数据后的所有账户都要重新计算一次哈希值。")]),t._v(" "),e("h3",{attrs:{id:"modify-mpt"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#modify-mpt"}},[t._v("#")]),t._v(" Modify MPT")]),t._v(" "),e("p",[t._v("在以太坊中，使用的数据结构是 "),e("code",[t._v("Modified MPT")]),t._v(" ，要理解这个结构，首先要理解接下来的几个结构：")]),t._v(" "),e("h4",{attrs:{id:"trie"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#trie"}},[t._v("#")]),t._v(" trie")]),t._v(" "),e("img",{attrs:{src:_(440),alt:"trie",width:"300px"}}),t._v(" "),e("p",[t._v("这就是一个 trie 的结构，其具有的特点：")]),t._v(" "),e("ol",[e("li",[t._v("在 trie 中，每个节点的分支数目取决于这个 key 值里每个元素的取值范围，以上面的例子为例，假设英文单词都是小写，那么一个字母的位置最多有 26 种可能性，所以 trie 中一个节点之后的分支，最多有 26 个。而对于以太坊的地址来说，由于是 16 进制的数，所以每个位置的取值范围是 0 ~ f ，一共 17 个；")]),t._v(" "),e("li",[t._v("trie 的查找效率取决于 key 的长度，key 越长，需要查找访问内存的次数就越多，在以太坊中，所有的 key 都是一样长的，都是 40 位；")]),t._v(" "),e("li",[t._v("不会出现碰撞，只要地址不同，就肯定可以映射到树中两个不同的分支，而之前提到的哈希表的方式，是有可能出现哈希碰撞的；")]),t._v(" "),e("li",[t._v("给定一组输入，不论以何种顺序插入到 trie 中，最终构成的 trie 是同一棵树；")]),t._v(" "),e("li",[t._v("更新的局部性是很好的，我觉得跟我之前提到的稳定性有相似之处。")])]),t._v(" "),e("p",[t._v("缺点：")]),t._v(" "),e("p",[t._v("存储有点浪费，对于一脉单传的情况，可以进行合并")]),t._v(" "),e("h4",{attrs:{id:"patricia-tree"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#patricia-tree"}},[t._v("#")]),t._v(" patricia tree")]),t._v(" "),e("p",[t._v("对 trie 进行路径压缩后的树，以上面的 trie 为例：")]),t._v(" "),e("img",{attrs:{src:_(441),alt:"patricia tree",width:"400px"}}),t._v(" "),e("p",[t._v("需要注意的是，如果插入一个新单词，那么之前压缩的部分可能需要扩展开。")]),t._v(" "),e("h4",{attrs:{id:"mpt-merkle-patricia-tree"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mpt-merkle-patricia-tree"}},[t._v("#")]),t._v(" MPT Merkle Patricia Tree")]),t._v(" "),e("p",[t._v("MPT 与 patricia tree 的区别是，在 MPT 中，父节点是通过哈希指针指向下一个节点的。")]),t._v(" "),e("p",[t._v("这样，从根节点开始，就有多条通过哈希指针连接的节点的路径，而这个根节点本身计算出的哈希值就作为块头中 "),e("code",[t._v("状态树")]),t._v(" 的哈希值。")]),t._v(" "),e("p",[t._v("在块头中保存 "),e("code",[t._v("状态树")]),t._v(" 的根哈希值，有如下几个作用：")]),t._v(" "),e("ol",[e("li",[t._v("防篡改")]),t._v(" "),e("li",[t._v("merkle proof ：证明一个账户的余额。将要检查的账户所在路径的所有节点都发送给轻节点，这样轻节点就可以验证账户的状态了。")]),t._v(" "),e("li",[t._v("可以证明一个账户不存在")])]),t._v(" "),e("h4",{attrs:{id:"modified-mpt"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#modified-mpt"}},[t._v("#")]),t._v(" Modified MPT")]),t._v(" "),e("p",[e("code",[t._v("Modified MPT")]),t._v(" 是以太坊中真正使用的 "),e("code",[t._v("状态树")]),t._v(" 的结构，如下图所示：")]),t._v(" "),e("p",[e("img",{attrs:{src:_(442),alt:"Merkle tree"}})]),t._v(" "),e("p",[t._v("注：为了方便绘图与讨论，这里用的地址只有 7 位。正常情况下有 40 位。")]),t._v(" "),e("p",[t._v("在上图中，节点与节点之间的连接是通过哈希指针实现的，也就是说，在 "),e("code",[t._v("Extension Node")]),t._v(" 的 "),e("code",[t._v("next node")]),t._v(" 字段内以及 "),e("code",[t._v("Branch Node")]),t._v(" 节点的字段内存储的都是子节点的哈希值。")]),t._v(" "),e("p",[e("code",[t._v("Extension Node")]),t._v(" ：如果这个路径出现了路径压缩，那么就会有一个 "),e("code",[t._v("Extension Node")]),t._v(" 。")]),t._v(" "),e("p",[t._v("另外，由图可知，根节点会取一个根哈希值，然后存储在 "),e("code",[t._v("Block Header")]),t._v(" 中。")]),t._v(" "),e("p",[t._v("每次发布一个新的区块的时候， "),e("code",[t._v("状态树")]),t._v(" 中有一些节点的值会发生变化，这些变化不是在原处修改，而是新建一些分支，原来的状态会保留下来，")]),t._v(" "),e("p",[e("img",{attrs:{src:_(443),alt:"Merkle tree"}})]),t._v(" "),e("p",[t._v("上面的例子中有两个连续的区块。由上图可知，虽然每个区块各有一个 "),e("code",[t._v("状态树")]),t._v(" ，但是大部分的节点是共享的，只有那些发生改变的节点，才需要新建一个分支。上图中，黄色背景的是节点。")]),t._v(" "),e("p",[t._v("另外，由上图也可知，合约账户中的存储（Storage）也是通过 MPT 的方式进行存储的，Storage 用于存储合约中变量的取值，本质上也是一个 (key, value) 的映射，所以也可以通过 MPT 进行存储。")]),t._v(" "),e("p",[e("strong",[t._v("问题：为什么要在每个区块中都保存一颗 "),e("code",[t._v("状态树")]),t._v(" ？")])]),t._v(" "),e("p",[t._v("为了回滚区块。")]),t._v(" "),e("p",[t._v("在以太坊中，由于每 15s 左右就会产生一个区块，所以发生分叉是很常见的情况。如果不是每个区块都关联一颗 "),e("code",[t._v("状态树")]),t._v(" ，那么要回滚区块的话，就需要回滚当前区块产生的所有操作，但是由于以太坊中存在智能合约，这个合约对应的编程语言是图灵完备的，一旦执行完毕后，就几乎不可能通过反向操作回到最初的状态，所以，每个区块都需要关联一颗 "),e("code",[t._v("状态树")]),t._v(" 。")]),t._v(" "),e("h2",{attrs:{id:"以太坊-block-header-的结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#以太坊-block-header-的结构"}},[t._v("#")]),t._v(" 以太坊 Block Header 的结构")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("字段")]),t._v(" "),e("th",[t._v("含义")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("ParentHash")]),t._v(" "),e("td",[t._v("父块的哈希，也就是前一个区块的哈希值")])]),t._v(" "),e("tr",[e("td",[t._v("UncleHash")]),t._v(" "),e("td",[t._v("叔块的哈希")])]),t._v(" "),e("tr",[e("td",[t._v("Coinbase")]),t._v(" "),e("td",[t._v("挖出该区块的矿工的账户地址")])]),t._v(" "),e("tr",[e("td",[t._v("Root")]),t._v(" "),e("td",[t._v("状态树的哈希值")])]),t._v(" "),e("tr",[e("td",[t._v("TxHash")]),t._v(" "),e("td",[t._v("交易树的哈希值")])]),t._v(" "),e("tr",[e("td",[t._v("ReceiptHash")]),t._v(" "),e("td",[t._v("收据树的哈希值")])]),t._v(" "),e("tr",[e("td",[t._v("Bloom")]),t._v(" "),e("td",[t._v("与收据树是相关的，提供一个高效的查询，查找符合某种条件的交易的执行结果")])]),t._v(" "),e("tr",[e("td",[t._v("Difficulty")]),t._v(" "),e("td",[t._v("挖矿难度")])]),t._v(" "),e("tr",[e("td",[t._v("GasLimit")]),t._v(" "),e("td",[t._v("与汽油费 gas 相关")])]),t._v(" "),e("tr",[e("td",[t._v("GasUsed")]),t._v(" "),e("td",[t._v("与汽油费 gas 相关")])]),t._v(" "),e("tr",[e("td",[t._v("Time")]),t._v(" "),e("td",[t._v("区块大致的产生时间")])]),t._v(" "),e("tr",[e("td",[t._v("Extra")]),t._v(" "),e("td")]),t._v(" "),e("tr",[e("td",[t._v("MixDigest")]),t._v(" "),e("td",[t._v("根据 Nonce 经过一些计算，得到的哈希值")])]),t._v(" "),e("tr",[e("td",[t._v("Nonce")]),t._v(" "),e("td",[t._v("随机数")])])])]),t._v(" "),e("h2",{attrs:{id:"以太坊区块的结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#以太坊区块的结构"}},[t._v("#")]),t._v(" 以太坊区块的结构")]),t._v(" "),e("div",{staticClass:"language-go extra-class"},[e("pre",{pre:!0,attrs:{class:"language-go"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// "external" block encoding. used for eth protocol, etc.')]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" extblock "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tHeader "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("Header\n\tTxs    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("Transaction\n\tUncles "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("Header\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("这是最终发布到区块链上的结构。")]),t._v(" "),e("h2",{attrs:{id:"状态树中值的存储"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#状态树中值的存储"}},[t._v("#")]),t._v(" 状态树中值的存储")]),t._v(" "),e("p",[t._v("状态树本质上是一个 (key, value) 的映射，在区块链中， value 会通过 "),e("strong",[t._v("RLP（Recursive Length Prefix）")]),t._v(" 编码序列化之后再存储。")])])}),[],!1,null,null,null);v.default=a.exports}}]);