(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{444:function(v,_,e){v.exports=e.p+"assets/img/bloom_filter.c2ebd62c.png"},445:function(v,_,e){v.exports=e.p+"assets/img/derive_sha.11999425.png"},481:function(v,_,e){"use strict";e.r(_);var t=e(65),r=Object(t.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[v._v("每次发布区块时，这个区块中的所有交易会组成一个 "),t("code",[v._v("交易树")]),v._v(" 。每个交易生成之后，也会相应地生成一个收据，记录这个交易的相关信息， "),t("code",[v._v("交易树")]),v._v(" 与 "),t("code",[v._v("收据树")]),v._v(" 上的节点是一一对应的。")]),v._v(" "),t("p",[v._v("增加 "),t("code",[v._v("收据树")]),v._v(" 的原因是：考虑到以太坊上的智能合约的执行过程比较复杂，所以通过增加收据树的结构，会有利于查询执行的结果。")]),v._v(" "),t("p",[v._v("从数据结构上来说， "),t("code",[v._v("交易树")]),v._v(" 和 "),t("code",[v._v("收据树")]),v._v(" 都是 MPT 结构。")]),v._v(" "),t("p",[v._v("对于 "),t("code",[v._v("状态树")]),v._v(" 来说，查询的键值是账户的地址，而对于 "),t("code",[v._v("交易树")]),v._v(" 和 "),t("code",[v._v("收据树")]),v._v(" 来说，查询的键值就是这个交易在发布的区块里的序号。")]),v._v(" "),t("p",[t("code",[v._v("交易树")]),v._v(" 和 "),t("code",[v._v("收据树")]),v._v(" 只包含当前区块中的交易，而 "),t("code",[v._v("状态树")]),v._v(" 包含所有账户的状态信息。")]),v._v(" "),t("h2",{attrs:{id:"两棵树的作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#两棵树的作用"}},[v._v("#")]),v._v(" 两棵树的作用")]),v._v(" "),t("ul",[t("li",[v._v("merkle proof ：证明某个交易在一个区块中")]),v._v(" "),t("li",[v._v("bloom filter：执行复杂的查询操作")])]),v._v(" "),t("h2",{attrs:{id:"bloom-filter"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bloom-filter"}},[v._v("#")]),v._v(" bloom filter")]),v._v(" "),t("p",[t("code",[v._v("bloom filter")]),v._v(" 这个数据结构可以支持比较高效的查找某个元素是否在一个大的集合中。")]),v._v(" "),t("p",[v._v("比如说，存在一个集合，里面有很多元素，现在希望确定某个指定的元素是不是在这个集合里，要怎么做？")]),v._v(" "),t("p",[v._v("最简单的想法是，把这个集合遍历一遍，确定是否有目标元素，这个复杂度是线性的，而且还有另外一个问题，就是在遍历时，需要在内存中存储整个集合的元素，但是对于 "),t("code",[v._v("轻节点")]),v._v(" 来说，其没有这个集合，所以对于轻节点来说，这种做法是不可行的。")]),v._v(" "),t("p",[t("code",[v._v("bloom filter")]),v._v(" 的思想是给这个集合计算出一个很紧凑的摘要（digest）。具体原理下述，先上图：")]),v._v(" "),t("p",[t("img",{attrs:{src:e(444),alt:"bloom filter"}})]),v._v(" "),t("p",[v._v("在上图中，上面的椭圆代表元素的集合，这里有三个元素：a、b、c。下面的一行数据块是对应元素生成的摘要。")]),v._v(" "),t("p",[v._v("元素到摘要的映射是通过一个哈希函数完成的。这个摘要相当于一个很长的数组（其实，就是一些 bits 位），映射到某个位置之后，将该位置标记为 1 。")]),v._v(" "),t("p",[v._v("但是，这里是可能会发生 "),t("strong",[v._v("哈希碰撞")]),v._v(" 的，也就是不同的元素映射到同一个位置。")]),v._v(" "),t("p",[v._v("假设，现在我们希望验证 d 元素是否在该集合内，那么只需要对 d 元素求哈希，如果哈希结果对应的位置为 0 ，那么 d 元素就一定不在该集合内，如果对应的位置为 1 ，那也不能说明 d 在集合内，因为可能恰好发生是哈希碰撞。")]),v._v(" "),t("p",[t("code",[v._v("bloom filter")]),v._v(" 的一个局限性是不支持删除操作。删除某个位置所对应的元素后，不能将该位置重置为 0 ，因为可能发生哈希碰撞导致存在其他元素映射到了该位置，除非在这个位置存储的是一个计数器。")]),v._v(" "),t("h2",{attrs:{id:"收据树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#收据树"}},[v._v("#")]),v._v(" 收据树")]),v._v(" "),t("p",[v._v("每个交易执行完成以后，会生成一个收据，这个收据里就包含了一个 "),t("code",[v._v("bloom filter")]),v._v(" ，记录这个交易的类型、地址等其他信息。")]),v._v(" "),t("p",[v._v("在发布的区块的块头里也有一个总的 "),t("code",[v._v("bloom filter")]),v._v(" ，这个 "),t("code",[v._v("bloom filter")]),v._v(" 是这个交易里的所有 "),t("code",[v._v("bloom filter")]),v._v(" 的并集。")]),v._v(" "),t("p",[v._v("假设，希望查询某种类型的交易，那么首先通过块头中的总 "),t("code",[v._v("bloom filter")]),v._v(" 来确定这个区块中是否有该类型的交易，如果没有，直接过滤掉该区块就可以了，如果有的话，再在交易树和收据树中查找对应类型的交易。")]),v._v(" "),t("h2",{attrs:{id:"交易驱动的状态机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#交易驱动的状态机"}},[v._v("#")]),v._v(" 交易驱动的状态机")]),v._v(" "),t("p",[v._v("以太坊的运行过程，可以把它看做是一个 "),t("code",[v._v("交易驱动的状态机（transaction-driven state machine）")]),v._v(" 。")]),v._v(" "),t("p",[v._v("这个状态机的状态就是所有账户的状态，也就是 "),t("code",[v._v("状态树")]),v._v(" 中包含的内容。")]),v._v(" "),t("p",[v._v("通过执行区块中的交易可以驱动状态机从一个状态转移到下一个状态。")]),v._v(" "),t("p",[v._v("比特币也可以认为其是一个状态机，其状态是 UTXO ，每次发布一个新的交易，都会从一个 UTXO 的状态转移到下一个状态。")]),v._v(" "),t("p",[v._v("比特币和以太坊状态机都有一个共同的特点就是状态的转移具有确定性，对于一个给定的当前状态以及一组给定的交易，能够 "),t("strong",[v._v("确定性")]),v._v(" 地转移到下一个状态。")]),v._v(" "),t("h2",{attrs:{id:"提问"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#提问"}},[v._v("#")]),v._v(" 提问")]),v._v(" "),t("h4",{attrs:{id:"为什么每个区块都要单独保存一颗完整的状态树的副本"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么每个区块都要单独保存一颗完整的状态树的副本"}},[v._v("#")]),v._v(" 为什么每个区块都要单独保存一颗完整的状态树的副本？")]),v._v(" "),t("p",[v._v("个人疑问：前面的课程不是提到，每个区块只保存修改的节点，其他节点都指向前一个区块的节点吗？")]),v._v(" "),t("p",[v._v("这是为了方便确定账户的余额等信息。如果不保存完整的副本，那么在确定一个账户的余额时，就要从最新的区块开始依次向前查找，直到找到该账户为止，如果该账户是新创建的，那么就要查找到创世区块，这样的查找过程类似于比特币的 UTXO 了。")]),v._v(" "),t("h2",{attrs:{id:"代码中创建新区块的流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码中创建新区块的流程"}},[v._v("#")]),v._v(" 代码中创建新区块的流程")]),v._v(" "),t("h3",{attrs:{id:"创建区块-newblock-函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建区块-newblock-函数"}},[v._v("#")]),v._v(" 创建区块——NewBlock 函数")]),v._v(" "),t("p",[v._v("位于源码中的 block.go 文件中， NewBlock 函数里调用 DeriveSha 来得到交易树和收据树的根哈希值。")]),v._v(" "),t("ol",[t("li",[v._v("创建交易树，计算根哈希值，创建交易列表")]),v._v(" "),t("li",[v._v("创建收据树，计算根哈希值，创建 bloom filter")]),v._v(" "),t("li",[v._v("计算叔父区块的哈希值，构建叔父数组")])]),v._v(" "),t("h3",{attrs:{id:"计算根哈希值-derivesha-函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#计算根哈希值-derivesha-函数"}},[v._v("#")]),v._v(" 计算根哈希值——DeriveSha 函数")]),v._v(" "),t("p",[v._v("derive_sha.go 中， DeriveSha 函数把 Transactions 和 Receipts 建为 trie 。")]),v._v(" "),t("p",[v._v("Trie 的数据结构如下：")]),v._v(" "),t("p",[t("img",{attrs:{src:e(445),alt:"derive sha"}})])])}),[],!1,null,null,null);_.default=r.exports}}]);