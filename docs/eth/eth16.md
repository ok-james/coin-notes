这一节主要讲解 ETH 是通过怎样的数据结构来存储账户信息的，包括余额、交易次数等。本质上需要存储的是从账户地址到账户状态的映射（ addr —> state）。

在 ETH 中，账户地址是 160 bits 的，一般表示成一个 40 位的 16 进制的数。

在比特币中，每个区块都对应着一个梅克尔树形式的交易树，并且会在块头中存储该梅克尔树的根哈希值。

而在以太坊中，每个区块都对应着三棵树，分别是 `状态树` 、 `交易树` 和 `收据树` ，在块头中，有三个字段分别存储着这三棵树的根哈希值。

而这一小节，主要讲解 `状态树` ，用来存储地址到状态的映射的树。

## 数据结构的讨论

存储 `状态树` 的数据结构需要满足如下要求：

1. 增、改、查的效率要高
2. 能够方便的计算所有账户的根哈希值
3. 节省存储空间，可以在连续的区块之间共享未修改的账户状态，也就是说，这个数据结构必须稳定，稳定的意思是，即使账户的状态修改，对于整个数据结构的结构来说，也没有影响。
4. 能够保证 `状态树` 的结构在整个网络的所有节点中都保持一致，即使节点之间没有互相同步过这个结构。

有如下几个选择：

### 哈希表

主要的问题是一旦一个区块内的所有交易和合约都执行完以后，需要根据最新的哈希表重新计算根哈希值。

个人疑问：是不是如果能够记录具体是哪个账户发生了变化，也不需要重新计算整个 `状态树` ？

个人理解：与接下来讨论的 `Modified MPT` 的方式进行比较后，我觉得，这种方式真正不好的地方是，无法在两个连续的区块之间重用未修改的账户状态，因为一旦账户的状态修改后，就可能跑到哈希表的另一个位置上，也就是说，前后两个区块的哈希表的结构可能会差别很大，这样就需要每个区块都保存一个所有账户的副本。

而对于 `Modified MPT` 结构来说，连续两个区块的结构都不会有大的改变，只有新增账户时，结构才会发生变化，而且，这不影响已有账户的结构。注意，我说的是结构。这样，就可以很方便的重用之前未修改的账户状态，而只需要在当前区块中记录已修改的账户即可。

### 梅克尔树

如果直接使用梅克尔树的结构存储账户，实际上就是用数组结构来存储账户。

#### 如果是未排序的数组

如果是未排序的数组，那么查的效率就会很慢。

老师在视频中还提出一个这种方式的问题，就是，在不同的节点之间，账户在数组中的顺序可能是不同的，从而无法在所有节点中保持唯一的一个状态树。

我不太认同老师的说法，理由如下：一旦确定一个新区块以后，该区块需要传播给所有其他节点，其他节点收到该区块后，需要执行该区块内的交易以及合约调用。该区块内所有交易以及合约调用的顺序都是相同的，那么，节点在执行这些交易与合约时，顺序应该也是相同的，假设遇到一个新账户，那么只需要直接放到数组的末尾就可以，理论上来说，在所有节点之间，该数组的状态是相同的。

所以，我认为，最严重的问题还是查的效率太慢了，同时造成改的效率也慢。

#### 如果是已排序的数组

如果是已排序的数组，查找的效率确实能快一点，但是新增的效率就会慢得多，总得来说，增、改、查的效率都比较慢，因为理论上来说，账户的总数量是 2^160 ，在这样的数量级下，这样的效率很明显是无法接受的。

而且，一旦新增数据，该数据后的所有账户都要重新计算一次哈希值。

### Modify MPT

在以太坊中，使用的数据结构是 `Modified MPT` ，要理解这个结构，首先要理解接下来的几个结构：

#### trie

<img src="~@/images/eth/eth16/trie.png" alt="trie" width="300px"/>

这就是一个 trie 的结构，其具有的特点：

1. 在 trie 中，每个节点的分支数目取决于这个 key 值里每个元素的取值范围，以上面的例子为例，假设英文单词都是小写，那么一个字母的位置最多有 26 种可能性，所以 trie 中一个节点之后的分支，最多有 26 个。而对于以太坊的地址来说，由于是 16 进制的数，所以每个位置的取值范围是 0 ~ f ，一共 17 个；
2. trie 的查找效率取决于 key 的长度，key 越长，需要查找访问内存的次数就越多，在以太坊中，所有的 key 都是一样长的，都是 40 位；
3. 不会出现碰撞，只要地址不同，就肯定可以映射到树中两个不同的分支，而之前提到的哈希表的方式，是有可能出现哈希碰撞的；
4. 给定一组输入，不论以何种顺序插入到 trie 中，最终构成的 trie 是同一棵树；
5. 更新的局部性是很好的，我觉得跟我之前提到的稳定性有相似之处。

缺点：

存储有点浪费，对于一脉单传的情况，可以进行合并

#### patricia tree

对 trie 进行路径压缩后的树，以上面的 trie 为例：

<img src="~@/images/eth/eth16/patricia_tree.png" alt="patricia tree" width="400px"/>

需要注意的是，如果插入一个新单词，那么之前压缩的部分可能需要扩展开。

#### MPT Merkle Patricia Tree

MPT 与 patricia tree 的区别是，在 MPT 中，父节点是通过哈希指针指向下一个节点的。

这样，从根节点开始，就有多条通过哈希指针连接的节点的路径，而这个根节点本身计算出的哈希值就作为块头中 `状态树` 的哈希值。

在块头中保存 `状态树` 的根哈希值，有如下几个作用：

1. 防篡改
2. merkle proof ：证明一个账户的余额。将要检查的账户所在路径的所有节点都发送给轻节点，这样轻节点就可以验证账户的状态了。
3. 可以证明一个账户不存在

#### Modified MPT

`Modified MPT` 是以太坊中真正使用的 `状态树` 的结构，如下图所示：

![Merkle tree](~@/images/eth/eth16/modified_MPT.png)

注：为了方便绘图与讨论，这里用的地址只有 7 位。正常情况下有 40 位。

在上图中，节点与节点之间的连接是通过哈希指针实现的，也就是说，在 `Extension Node` 的 `next node` 字段内以及 `Branch Node` 节点的字段内存储的都是子节点的哈希值。

`Extension Node` ：如果这个路径出现了路径压缩，那么就会有一个 `Extension Node` 。

另外，由图可知，根节点会取一个根哈希值，然后存储在 `Block Header` 中。

每次发布一个新的区块的时候， `状态树` 中有一些节点的值会发生变化，这些变化不是在原处修改，而是新建一些分支，原来的状态会保留下来，

![Merkle tree](~@/images/eth/eth16/saved_MPT.png)

上面的例子中有两个连续的区块。由上图可知，虽然每个区块各有一个 `状态树` ，但是大部分的节点是共享的，只有那些发生改变的节点，才需要新建一个分支。上图中，黄色背景的是节点。

另外，由上图也可知，合约账户中的存储（Storage）也是通过 MPT 的方式进行存储的，Storage 用于存储合约中变量的取值，本质上也是一个 (key, value) 的映射，所以也可以通过 MPT 进行存储。

**问题：为什么要在每个区块中都保存一颗 `状态树` ？**

为了回滚区块。

在以太坊中，由于每 15s 左右就会产生一个区块，所以发生分叉是很常见的情况。如果不是每个区块都关联一颗 `状态树` ，那么要回滚区块的话，就需要回滚当前区块产生的所有操作，但是由于以太坊中存在智能合约，这个合约对应的编程语言是图灵完备的，一旦执行完毕后，就几乎不可能通过反向操作回到最初的状态，所以，每个区块都需要关联一颗 `状态树` 。

## 以太坊 Block Header 的结构

| 字段 | 含义 |
| --- | --- |
| ParentHash | 父块的哈希，也就是前一个区块的哈希值 |
| UncleHash | 叔块的哈希 |
| Coinbase | 挖出该区块的矿工的账户地址 |
| Root | 状态树的哈希值 |
| TxHash | 交易树的哈希值 |
| ReceiptHash | 收据树的哈希值 |
| Bloom | 与收据树是相关的，提供一个高效的查询，查找符合某种条件的交易的执行结果 |
| Difficulty | 挖矿难度 |
| GasLimit | 与汽油费 gas 相关 |
| GasUsed | 与汽油费 gas 相关 |
| Time | 区块大致的产生时间 |
| Extra |  |
| MixDigest | 根据 Nonce 经过一些计算，得到的哈希值 |
| Nonce | 随机数 |

## 以太坊区块的结构

```go
// "external" block encoding. used for eth protocol, etc.
type extblock struct {
	Header *Header
	Txs    []*Transaction
	Uncles []*Header
}
```

这是最终发布到区块链上的结构。

## 状态树中值的存储

状态树本质上是一个 (key, value) 的映射，在区块链中， value 会通过 **RLP（Recursive Length Prefix）** 编码序列化之后再存储。
